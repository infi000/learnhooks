{"ast":null,"code":"import _slicedToArray from \"/Users/sf/Desktop/zcy/hooksdemo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useState, useEffect, useCallback, useRef } from \"react\"; // 1、通过useRef创建一个对象；\n// 2、将需要执行的定时任务储存在这个对象上；\n// 3、将time作为第二个参数是为了当我们动态改变定时任务时，能过重新执行定时器。\n\nexport var useInterval = function useInterval(callback) {\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var intervalFn = useRef({}); // 1\n\n  useEffect(function () {\n    intervalFn.current.fn = callback; // 2\n  });\n  useEffect(function () {\n    intervalFn.current.timer = setInterval(function () {\n      intervalFn.current.fn();\n    }, time);\n    return function () {\n      clearInterval(intervalFn.current.timer);\n    };\n  }, []); // 3\n\n  return intervalFn.current.timer;\n}; //效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\n\nexport var useInputValue = function useInputValue(val) {\n  var _useState = useState(val),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var onChange = useCallback(function (event) {\n    setValue(event.currentTarget.value);\n  }, []);\n  return {\n    value: value,\n    onChange: onChange\n  };\n}; //获取上一轮的props\n\nexport var usePreValue = function usePreValue(val) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = val; //变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\nexport var useTitle = function useTitle(title) {\n  useEffect(function () {\n    document.title = title;\n    return function () {\n      return document.title = \"主页\";\n    };\n  }, [title]);\n};","map":{"version":3,"sources":["/Users/sf/Desktop/zcy/hooksdemo/src/demos/utils/hooks.js"],"names":["React","useState","useEffect","useCallback","useRef","useInterval","callback","time","intervalFn","current","fn","timer","setInterval","clearInterval","useInputValue","val","value","setValue","onChange","event","currentTarget","usePreValue","ref","useTitle","title","document"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,MAAlD,QAAgE,OAAhE,C,CACA;AACA;AACA;;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,QAAD,EAA0B;AAAA,MAAfC,IAAe,uEAAR,GAAQ;AACnD,MAAMC,UAAU,GAAGJ,MAAM,CAAC,EAAD,CAAzB,CADmD,CACpB;;AAC/BF,EAAAA,SAAS,CAAC,YAAM;AACdM,IAAAA,UAAU,CAACC,OAAX,CAAmBC,EAAnB,GAAwBJ,QAAxB,CADc,CACoB;AACnC,GAFQ,CAAT;AAGAJ,EAAAA,SAAS,CAAC,YAAM;AACdM,IAAAA,UAAU,CAACC,OAAX,CAAmBE,KAAnB,GAA2BC,WAAW,CAAC,YAAM;AAC3CJ,MAAAA,UAAU,CAACC,OAAX,CAAmBC,EAAnB;AACD,KAFqC,EAEnCH,IAFmC,CAAtC;AAGA,WAAO,YAAM;AACXM,MAAAA,aAAa,CAACL,UAAU,CAACC,OAAX,CAAmBE,KAApB,CAAb;AACD,KAFD;AAGD,GAPQ,EAON,EAPM,CAAT,CALmD,CAY3C;;AAER,SAAOH,UAAU,CAACC,OAAX,CAAmBE,KAA1B;AACD,CAfM,C,CAiBP;AACA;;AACA,OAAO,IAAMG,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,GAAG,EAAI;AAAA,kBACVd,QAAQ,CAACc,GAAD,CADE;AAAA;AAAA,MAC7BC,KAD6B;AAAA,MACtBC,QADsB;;AAElC,MAAIC,QAAQ,GAAGf,WAAW,CAAC,UAASgB,KAAT,EAAgB;AACzCF,IAAAA,QAAQ,CAACE,KAAK,CAACC,aAAN,CAAoBJ,KAArB,CAAR;AACD,GAFyB,EAEvB,EAFuB,CAA1B;AAGA,SAAO;AACLA,IAAAA,KAAK,EAALA,KADK;AAELE,IAAAA,QAAQ,EAARA;AAFK,GAAP;AAID,CATM,C,CAWP;;AACA,OAAO,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAAAN,GAAG,EAAI;AAChC,MAAMO,GAAG,GAAGlB,MAAM,EAAlB;AACAF,EAAAA,SAAS,CAAC,YAAM;AACdoB,IAAAA,GAAG,CAACb,OAAJ,GAAcM,GAAd,CADc,CACK;AACpB,GAFQ,CAAT;AAGA,SAAOO,GAAG,CAACb,OAAX;AACD,CANM;AAQP,OAAO,IAAMc,QAAQ,GAAG,SAAXA,QAAW,CAAAC,KAAK,EAAI;AAC/BtB,EAAAA,SAAS,CAAC,YAAM;AACduB,IAAAA,QAAQ,CAACD,KAAT,GAAiBA,KAAjB;AACA,WAAO;AAAA,aAAOC,QAAQ,CAACD,KAAT,GAAiB,IAAxB;AAAA,KAAP;AACD,GAHQ,EAGN,CAACA,KAAD,CAHM,CAAT;AAID,CALM","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from \"react\";\n// 1、通过useRef创建一个对象；\n// 2、将需要执行的定时任务储存在这个对象上；\n// 3、将time作为第二个参数是为了当我们动态改变定时任务时，能过重新执行定时器。\nexport const useInterval = (callback, time = 300) => {\n  const intervalFn = useRef({}); // 1\n  useEffect(() => {\n    intervalFn.current.fn = callback; // 2\n  });\n  useEffect(() => {\n    intervalFn.current.timer = setInterval(() => {\n      intervalFn.current.fn();\n    }, time);\n    return () => {\n      clearInterval(intervalFn.current.timer);\n    };\n  }, []); // 3\n\n  return intervalFn.current.timer;\n};\n\n//效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\nexport const useInputValue = val => {\n  let [value, setValue] = useState(val);\n  let onChange = useCallback(function(event) {\n    setValue(event.currentTarget.value);\n  }, []);\n  return {\n    value,\n    onChange\n  };\n};\n\n//获取上一轮的props\nexport const usePreValue = val => {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = val; //变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\n\nexport const useTitle = title => {\n  useEffect(() => {\n    document.title = title;\n    return () => (document.title = \"主页\");\n  }, [title]);\n};\n"]},"metadata":{},"sourceType":"module"}