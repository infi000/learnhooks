{"ast":null,"code":"import _slicedToArray from \"/Users/zhangchiyang/Desktop/study/learnhooks/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/zhangchiyang/Desktop/study/learnhooks/src/demos/hooks/ComRules.jsx\";\n//React 不知道第二个 useState 的 Hook 应该返回什么。\n//React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应得是 persistForm 的 effect，但并非如此。\n//从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。\nimport React, { useEffect, useState } from \"react\";\n\nfunction App() {\n  var _useState = useState(\"Mary\"),\n      _useState2 = _slicedToArray(_useState, 2),\n      name = _useState2[0],\n      setName = _useState2[1]; // if (typeof name !== \"number\") {\n  //   useEffect(function persistForm() {\n  //     localStorage.setItem(\"formData\", name);\n  //   });\n  // }\n\n\n  useEffect(function persistForm() {\n    localStorage.setItem(\"formData\", name);\n  });\n\n  var _useState3 = useState(\"Poppins\"),\n      _useState4 = _slicedToArray(_useState3, 2),\n      surname = _useState4[0],\n      setSurname = _useState4[1];\n\n  useEffect(function updateTitle() {\n    document.title = name + \" \" + surname;\n  });\n  return React.createElement(\"button\", {\n    onClick: function onClick() {\n      setName(Number(new Date()));\n    },\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25\n    },\n    __self: this\n  }, \"click\");\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/zhangchiyang/Desktop/study/learnhooks/src/demos/hooks/ComRules.jsx"],"names":["React","useEffect","useState","App","name","setName","persistForm","localStorage","setItem","surname","setSurname","updateTitle","document","title","Number","Date"],"mappings":";;AAAA;AACA;AACA;AAEA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,QAA2C,OAA3C;;AAEA,SAASC,GAAT,GAAe;AAAA,kBACWD,QAAQ,CAAC,MAAD,CADnB;AAAA;AAAA,MACNE,IADM;AAAA,MACAC,OADA,kBAGb;AACA;AACA;AACA;AACA;;;AACEJ,EAAAA,SAAS,CAAC,SAASK,WAAT,GAAuB;AAC/BC,IAAAA,YAAY,CAACC,OAAb,CAAqB,UAArB,EAAiCJ,IAAjC;AACD,GAFQ,CAAT;;AARW,mBAYiBF,QAAQ,CAAC,SAAD,CAZzB;AAAA;AAAA,MAYNO,OAZM;AAAA,MAYGC,UAZH;;AAabT,EAAAA,SAAS,CAAC,SAASU,WAAT,GAAuB;AAC/BC,IAAAA,QAAQ,CAACC,KAAT,GAAiBT,IAAI,GAAG,GAAP,GAAaK,OAA9B;AACD,GAFQ,CAAT;AAIA,SACE;AACE,IAAA,OAAO,EAAE,mBAAM;AACbJ,MAAAA,OAAO,CAACS,MAAM,CAAC,IAAIC,IAAJ,EAAD,CAAP,CAAP;AACD,KAHH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aADF;AASD;;AAED,eAAeZ,GAAf","sourcesContent":["//React 不知道第二个 useState 的 Hook 应该返回什么。\n//React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应得是 persistForm 的 effect，但并非如此。\n//从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。\n\nimport React, { useEffect, useState } from \"react\";\n\nfunction App() {\n  const [name, setName] = useState(\"Mary\");\n\n  // if (typeof name !== \"number\") {\n  //   useEffect(function persistForm() {\n  //     localStorage.setItem(\"formData\", name);\n  //   });\n  // }\n    useEffect(function persistForm() {\n      localStorage.setItem(\"formData\", name);\n    });\n\n  const [surname, setSurname] = useState(\"Poppins\");\n  useEffect(function updateTitle() {\n    document.title = name + \" \" + surname;\n  });\n\n  return (\n    <button\n      onClick={() => {\n        setName(Number(new Date()));\n      }}\n    >\n      click\n    </button>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}