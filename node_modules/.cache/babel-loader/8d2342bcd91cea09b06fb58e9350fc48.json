{"ast":null,"code":"import _slicedToArray from \"/Users/sf/Desktop/zcy/hooksdemo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useState, useEffect, useCallback, useRef } from \"react\"; //效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\n\nexport var useInputValue = function useInputValue(val) {\n  var _useState = useState(val),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var onChange = useCallback(function (event) {\n    setValue(event.currentTarget.value);\n    console.log(value);\n  }, []);\n  return {\n    value: value,\n    onChange: onChange\n  };\n}; //获取上一轮的props\n\nexport var usePreValue = function usePreValue(val) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = val; //变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\nexport var useTitle = function useTitle(title) {\n  useEffect(function () {\n    document.title = title;\n    return function () {\n      return document.title = \"主页\";\n    };\n  }, [title]);\n};","map":{"version":3,"sources":["/Users/sf/Desktop/zcy/hooksdemo/src/demos/utils/hooks.js"],"names":["React","useState","useEffect","useCallback","useRef","useInputValue","val","value","setValue","onChange","event","currentTarget","console","log","usePreValue","ref","current","useTitle","title","document"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,MAAlD,QAAgE,OAAhE,C,CAEA;AACA;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,GAAG,EAAI;AAAA,kBACVL,QAAQ,CAACK,GAAD,CADE;AAAA;AAAA,MAC7BC,KAD6B;AAAA,MACtBC,QADsB;;AAElC,MAAIC,QAAQ,GAAGN,WAAW,CAAC,UAASO,KAAT,EAAgB;AACzCF,IAAAA,QAAQ,CAACE,KAAK,CAACC,aAAN,CAAoBJ,KAArB,CAAR;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAYN,KAAZ;AACD,GAHyB,EAGvB,EAHuB,CAA1B;AAIA,SAAO;AACLA,IAAAA,KAAK,EAALA,KADK;AAELE,IAAAA,QAAQ,EAARA;AAFK,GAAP;AAID,CAVM,C,CAaP;;AACA,OAAO,IAAMK,WAAW,GAAG,SAAdA,WAAc,CAAAR,GAAG,EAAI;AAChC,MAAMS,GAAG,GAAGX,MAAM,EAAlB;AACAF,EAAAA,SAAS,CAAC,YAAM;AACda,IAAAA,GAAG,CAACC,OAAJ,GAAcV,GAAd,CADc,CACI;AACnB,GAFQ,CAAT;AAGA,SAAOS,GAAG,CAACC,OAAX;AACD,CANM;AASP,OAAO,IAAMC,QAAQ,GAAE,SAAVA,QAAU,CAACC,KAAD,EAAW;AAChChB,EAAAA,SAAS,CACP,YAAM;AACJiB,IAAAA,QAAQ,CAACD,KAAT,GAAiBA,KAAjB;AACA,WAAO;AAAA,aAAOC,QAAQ,CAACD,KAAT,GAAiB,IAAxB;AAAA,KAAP;AACD,GAJM,EAKP,CAACA,KAAD,CALO,CAAT;AAOD,CARM","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from \"react\";\n\n//效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\nexport const useInputValue = val => {\n  let [value, setValue] = useState(val);\n  let onChange = useCallback(function(event) {\n    setValue(event.currentTarget.value);\n    console.log(value);\n  }, []);\n  return {\n    value,\n    onChange\n  };\n};\n\n\n//获取上一轮的props\nexport const usePreValue = val => {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = val;//变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\n\n\nexport const useTitle =(title) => {\n  useEffect(\n    () => {\n      document.title = title;\n      return () => (document.title = \"主页\");\n    },\n    [title]\n  );\n}\n\n"]},"metadata":{},"sourceType":"module"}