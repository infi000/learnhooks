{"ast":null,"code":"import _slicedToArray from \"/Users/sf/Desktop/zcy/hooksdemo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { useState, useEffect, useCallback, useRef } from \"react\";\n\nvar useInterval = function useInterval(callback) {\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n  var intervalFn = useRef(); // 1\n\n  useEffect(function () {\n    intervalFn.current = callback; // 2\n  });\n  useEffect(function () {\n    var timer = setInterval(function () {\n      intervalFn.current();\n    }, time);\n    return function () {\n      clearInterval(timer);\n    };\n  }, [time]); // 3\n}; //效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\n\n\nexport var useInputValue = function useInputValue(val) {\n  var _useState = useState(val),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var onChange = useCallback(function (event) {\n    setValue(event.currentTarget.value);\n  }, []);\n  return {\n    value: value,\n    onChange: onChange\n  };\n}; //获取上一轮的props\n\nexport var usePreValue = function usePreValue(val) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = val; //变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\nexport var useTitle = function useTitle(title) {\n  useEffect(function () {\n    document.title = title;\n    return function () {\n      return document.title = \"主页\";\n    };\n  }, [title]);\n};","map":{"version":3,"sources":["/Users/sf/Desktop/zcy/hooksdemo/src/demos/utils/hooks.js"],"names":["React","useState","useEffect","useCallback","useRef","useInterval","callback","time","intervalFn","current","timer","setInterval","clearInterval","useInputValue","val","value","setValue","onChange","event","currentTarget","usePreValue","ref","useTitle","title","document"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,EAAkDC,MAAlD,QAAgE,OAAhE;;AAGA,IAAOC,WAAW,GAAG,SAAdA,WAAc,CAACC,QAAD,EAA0B;AAAA,MAAfC,IAAe,uEAAR,GAAQ;AAC7C,MAAMC,UAAU,GAAGJ,MAAM,EAAzB,CAD6C,CAChB;;AAC7BF,EAAAA,SAAS,CAAC,YAAM;AACdM,IAAAA,UAAU,CAACC,OAAX,GAAqBH,QAArB,CADc,CACiB;AAChC,GAFQ,CAAT;AAGAJ,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMQ,KAAK,GAAGC,WAAW,CAAC,YAAM;AAC9BH,MAAAA,UAAU,CAACC,OAAX;AACD,KAFwB,EAEtBF,IAFsB,CAAzB;AAGA,WAAO,YAAM;AACXK,MAAAA,aAAa,CAACF,KAAD,CAAb;AACD,KAFD;AAGD,GAPQ,EAON,CAACH,IAAD,CAPM,CAAT,CAL6C,CAYjC;AACb,CAbD,C,CAiBA;AACA;;;AACA,OAAO,IAAMM,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,GAAG,EAAI;AAAA,kBACVb,QAAQ,CAACa,GAAD,CADE;AAAA;AAAA,MAC7BC,KAD6B;AAAA,MACtBC,QADsB;;AAElC,MAAIC,QAAQ,GAAGd,WAAW,CAAC,UAASe,KAAT,EAAgB;AACzCF,IAAAA,QAAQ,CAACE,KAAK,CAACC,aAAN,CAAoBJ,KAArB,CAAR;AACD,GAFyB,EAEvB,EAFuB,CAA1B;AAGA,SAAO;AACLA,IAAAA,KAAK,EAALA,KADK;AAELE,IAAAA,QAAQ,EAARA;AAFK,GAAP;AAID,CATM,C,CAYP;;AACA,OAAO,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAAAN,GAAG,EAAI;AAChC,MAAMO,GAAG,GAAGjB,MAAM,EAAlB;AACAF,EAAAA,SAAS,CAAC,YAAM;AACdmB,IAAAA,GAAG,CAACZ,OAAJ,GAAcK,GAAd,CADc,CACI;AACnB,GAFQ,CAAT;AAGA,SAAOO,GAAG,CAACZ,OAAX;AACD,CANM;AASP,OAAO,IAAMa,QAAQ,GAAE,SAAVA,QAAU,CAACC,KAAD,EAAW;AAChCrB,EAAAA,SAAS,CACP,YAAM;AACJsB,IAAAA,QAAQ,CAACD,KAAT,GAAiBA,KAAjB;AACA,WAAO;AAAA,aAAOC,QAAQ,CAACD,KAAT,GAAiB,IAAxB;AAAA,KAAP;AACD,GAJM,EAKP,CAACA,KAAD,CALO,CAAT;AAOD,CARM","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from \"react\";\n\n\nconst  useInterval = (callback, time = 300) => {\n  const intervalFn = useRef(); // 1\n  useEffect(() => {\n    intervalFn.current = callback; // 2\n  });\n  useEffect(() => {\n    const timer = setInterval(() => {\n      intervalFn.current();\n    }, time);\n    return () => {\n      clearInterval(timer);\n    };\n  }, [time]); // 3\n}\n\n\n\n//效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。\n//这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。\nexport const useInputValue = val => {\n  let [value, setValue] = useState(val);\n  let onChange = useCallback(function(event) {\n    setValue(event.currentTarget.value);\n  }, []);\n  return {\n    value,\n    onChange\n  };\n};\n\n\n//获取上一轮的props\nexport const usePreValue = val => {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = val;//变更 .current 属性不会引发组件重新渲染\n  });\n  return ref.current;\n};\n\n\nexport const useTitle =(title) => {\n  useEffect(\n    () => {\n      document.title = title;\n      return () => (document.title = \"主页\");\n    },\n    [title]\n  );\n}\n\n"]},"metadata":{},"sourceType":"module"}